using UnityEngine;
using System.Collections;

public class ModernFPSCamera : MonoBehaviour
{
    [Header("References")]
    [Tooltip("The player's transform (the one with Rigidbody)")]
    public Transform player;

    [Tooltip("Camera holder - create empty GameObject as child of player")]
    public Transform cameraHolder;

    [Tooltip("Visual model to bob when moving (assign in Inspector)")]
    public Transform playerModel;

    [Header("Mouse Settings")]
    [Range(1f, 1000f)]
    public float mouseSensitivity = 400f;

    [Tooltip("Invert Y-axis (up/down)")]
    public bool invertY = false;

    [Header("Camera Limits")]
    [Range(60f, 90f)]
    public float maxLookAngle = 90f;

    [Header("Position Settings")]
    [Tooltip("Camera offset from player center (height mostly)")]
    public Vector3 cameraOffset = new Vector3(0f, 0.6f, 0f);

    [Header("Model Bobbing")]
    public float modelBobFrequency = 6f;
    public float modelBobVerticalAmplitude = 0.08f;
    public float modelBobSmooth = 10f;
    public float groundCheckDistance = 1.2f;
    public LayerMask groundLayer;

    private float xRotation = 0f;
    private float yRotation = 0f;
    private float modelBobTimer = 0f;
    private Vector3 modelStartLocalPos;
    private Rigidbody playerRb;

    // Teleport handling
    private bool cameraPaused = false;

    void Start()
    {
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;

        if (player == null)
        {
            Debug.LogError("Player reference not assigned!");
            enabled = false;
            return;
        }

        if (cameraHolder == null)
        {
            cameraHolder = transform;
        }

        playerRb = player.GetComponent<Rigidbody>();

        if (playerModel != null)
        {
            modelStartLocalPos = playerModel.localPosition;
        }

        yRotation = player.eulerAngles.y;

        // Don't set FOV here - let SettingsManager handle it
        // Removed: playerCamera.fieldOfView = normalFOV;

        Debug.Log("FPS Camera Ready!");
    }

    void Update()
    {
        // ESC handling removed - now handled by PauseManager
        // Only handle mouse look when cursor is locked (not paused)
        if (Cursor.lockState == CursorLockMode.Locked)
        {
            HandleMouseLook();
        }
    }

    void LateUpdate()
    {
        // Keep camera synced to player AFTER physics (prevents jitter)
        if (!cameraPaused)
        {
            UpdateCameraPosition();
        }

        // Handle visual model bobbing
        HandleModelBobbing();
    }

    void HandleMouseLook()
    {
        float mouseX = Input.GetAxisRaw("Mouse X") * mouseSensitivity * Time.deltaTime;
        float mouseY = Input.GetAxisRaw("Mouse Y") * mouseSensitivity * Time.deltaTime;

        if (invertY) mouseY = -mouseY;

        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -maxLookAngle, maxLookAngle);

        yRotation += mouseX;

        cameraHolder.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
        player.rotation = Quaternion.Euler(0f, yRotation, 0f);
    }

    void UpdateCameraPosition()
    {
        cameraHolder.position = player.position + cameraOffset;
    }

    void HandleModelBobbing()
    {
        if (playerModel == null || playerRb == null)
            return;

        bool grounded = Physics.Raycast(
            player.position,
            Vector3.down,
            groundCheckDistance,
            groundLayer
        );

        Vector3 horizontalVelocity = new Vector3(
            playerRb.linearVelocity.x,
            0f,
            playerRb.linearVelocity.z
        );

        float speed = horizontalVelocity.magnitude;

        if (grounded && speed > 0.1f)
        {
            modelBobTimer += Time.deltaTime * modelBobFrequency * speed * 0.1f;

            float verticalBob = Mathf.Sin(modelBobTimer) * modelBobVerticalAmplitude;

            Vector3 targetPos = modelStartLocalPos + new Vector3(0f, verticalBob, 0f);
            playerModel.localPosition = Vector3.Lerp(
                playerModel.localPosition,
                targetPos,
                Time.deltaTime * modelBobSmooth
            );
        }
        else
        {
            modelBobTimer = 0f;
            playerModel.localPosition = Vector3.Lerp(
                playerModel.localPosition,
                modelStartLocalPos,
                Time.deltaTime * modelBobSmooth
            );
        }
    }

    public void SetSensitivity(float sensitivity)
    {
        mouseSensitivity = Mathf.Clamp(sensitivity, 1f, 1000f);
    }

    // Public method to pause camera updates during teleport
    public void PauseCameraUpdate(float duration)
    {
        StartCoroutine(PauseCameraCoroutine(duration));
    }

    IEnumerator PauseCameraCoroutine(float duration)
    {
        cameraPaused = true;
        yield return new WaitForSeconds(duration);
        cameraPaused = false;
    }
}
