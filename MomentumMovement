using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class MomentumMovement : MonoBehaviour
{
    [Header("Movement Settings")]
    [Range(20f, 100f)] public float moveSpeed = 50f;
    [Range(1f, 500f)] public float maxSpeed = 150f;
    [Range(20f, 150f)] public float acceleration = 50f;
    [Range(0f, 1f)] public float airControl = 0.5f;

    [Header("Gravity Settings")]
    [Range(1f, 25f)] public float gravityMultiplier = 2.5f;

    [Header("Jump Settings")]
    [Range(1f, 20f)] public float jumpForce = 12f;

    [Header("Slide Settings")]
    [Range(1f, 20f)] private float slideMinSpeed = 5f;
    [Range(0f, 75f)] public float slideBoost = 30f;
    [Range(0f, 5f)] public float slideDrag = 2f;
    [Range(0.4f, 1f)] public float slideHeightMultiplier = 0.6f;
    [Range(0f, 60f)] public float slideTiltAngle = 25f;

    [Header("Slide Tilt Tuning")]
    [Range(1f, 20f)] public float slideTiltSpeed = 12f;
    [Range(0f, 1f)] public float slideTiltStrength = 1f;

    [Header("Wall Slide Settings")]
    [Range(1f, 100f)] public float wallSlideSpeed = 2f;
    [Range(1f, 50f)] public float wallJumpForce = 15f;
    [Range(0f, 0.5f)] public float wallJumpDuration = 0.2f;

    [Header("Wall Slide Tilt")]
    public bool enableWallSlideTilt = true;
    [Range(0f, 45f)] public float wallSlideTiltAngle = 15f;

    [Header("Drag Settings")]
    [Range(0f, 20f)] public float groundDrag = 5f;
    [Range(0f, 20f)] public float airDrag = 0.5f;

    [Header("Ground Check")]
    public LayerMask groundMask;
    [Range(0.1f, 1f)] public float groundDistance = 0.2f;

    [Header("References")]
    public Transform playerModel;

    [Header("Footstep Audio")]
    public AudioSource footstepSource;
    public AudioClip[] footstepClips;
    public float footstepMinSpeed = 1.5f;
    public float maxFootstepRate = 6f;

    Rigidbody rb;
    CapsuleCollider capsule;

    Vector3 moveInput;
    Vector3 wallNormal;
    Vector3 slideDirection;

    bool isGrounded;
    bool isSliding;
    bool isWallSliding;

    float normalHeight;
    float slideHeight;
    Vector3 normalCenter;
    Vector3 slideCenter;

    float coyoteTime = 0.1f;
    float coyoteCounter;
    float wallJumpTimer;
    float footstepTimer;

    void Start()
    {
        rb = GetComponent<Rigidbody>();
        capsule = GetComponentInChildren<CapsuleCollider>();

        rb.freezeRotation = true;
        rb.interpolation = RigidbodyInterpolation.Interpolate;

        CreateFrictionlessMaterial();

        normalHeight = capsule.height;
        slideHeight = normalHeight * slideHeightMultiplier;

        normalCenter = capsule.center;
        slideCenter = new Vector3(
            normalCenter.x,
            slideHeight * 0.5f,
            normalCenter.z
        );
    }

    void Update()
    {
        CheckGround();
        HandleInput();
        HandleFootsteps();

        if (isSliding)
            HandleSlideTilt();

        if (isGrounded)
            coyoteCounter = coyoteTime;
        else
            coyoteCounter -= Time.deltaTime;

        if (wallJumpTimer > 0f)
            wallJumpTimer -= Time.deltaTime;

        if (!isSliding && !isWallSliding)
            ResetModelRotation();
    }

    void FixedUpdate()
    {
        if (wallJumpTimer <= 0f)
            MovePlayer();

        HandleWallSlidePhysics();
        ApplyExtraGravity();
        ApplyDrag();
        ClampSpeed();
    }

    // -------------------- Footsteps --------------------

    void HandleFootsteps()
    {
        if (!isGrounded) return;
        if (isSliding || isWallSliding) return;
        if (!footstepSource || footstepClips.Length == 0) return;

        Vector3 horiz = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
        float speed = horiz.magnitude;

        if (speed < footstepMinSpeed) return;

        float speed01 = Mathf.Clamp01(speed / maxSpeed);
        float stepRate = Mathf.Lerp(2f, maxFootstepRate, speed01);
        float interval = 1f / stepRate;

        footstepTimer += Time.deltaTime;

        if (footstepTimer >= interval)
        {
            footstepTimer = 0f;
            footstepSource.pitch = Random.Range(0.95f, 1.05f);
            footstepSource.PlayOneShot(
                footstepClips[Random.Range(0, footstepClips.Length)]
            );
        }
    }

    // -------------------- Slide Tilt (FIXED) --------------------

    void HandleSlideTilt()
    {
        if (!playerModel) return;

        Vector3 horiz = HorizontalVelocity();
        if (horiz.sqrMagnitude < 0.1f) return;

        float speed01 = Mathf.Clamp01(horiz.magnitude / maxSpeed);
        float tilt = slideTiltAngle * speed01 * slideTiltStrength;

        Vector3 axis = Vector3.Cross(horiz.normalized, Vector3.up);

        Quaternion target =
            Quaternion.AngleAxis(tilt, axis) * transform.rotation;

        playerModel.rotation = Quaternion.Slerp(
            playerModel.rotation,
            target,
            Time.deltaTime * slideTiltSpeed
        );
    }

    // -------------------- Input --------------------

    void HandleInput()
    {
        float h = Input.GetAxisRaw("Horizontal");
        float v = Input.GetAxisRaw("Vertical");
        moveInput = (transform.right * h + transform.forward * v).normalized;

        if (Input.GetKeyDown(KeyCode.Space))
        {
            if (isWallSliding)
                WallJump();
            else if (isGrounded || coyoteCounter > 0f)
                Jump();
        }

        if (Input.GetKeyDown(KeyCode.LeftShift))
        {
            float speed = HorizontalVelocity().magnitude;
            if (isGrounded && speed >= slideMinSpeed)
                StartSlide();
        }

        if (Input.GetKeyUp(KeyCode.LeftShift))
            StopSlide();
    }

    // -------------------- Movement --------------------

    void MovePlayer()
    {
        if (isSliding || isWallSliding) return;

        Vector3 target = moveInput * moveSpeed;
        Vector3 current = HorizontalVelocity();

        float control = isGrounded ? 1f : airControl;
        Vector3 change = (target - current) * control;
        change = Vector3.ClampMagnitude(change, acceleration * Time.fixedDeltaTime);

        rb.AddForce(change, ForceMode.VelocityChange);
    }

    // -------------------- Slide --------------------

    void StartSlide()
    {
        if (isSliding) return;

        isSliding = true;

        slideDirection = HorizontalVelocity().normalized;
        rb.AddForce(slideDirection * slideBoost, ForceMode.VelocityChange);

        capsule.height = slideHeight;
        capsule.center = slideCenter;
    }

    void StopSlide()
    {
        if (!isSliding) return;
        if (!CanStandUp()) return;

        isSliding = false;

        capsule.height = normalHeight;
        capsule.center = normalCenter;
    }

    bool CanStandUp()
    {
        float castDist = normalHeight - slideHeight + 0.1f;
        return !Physics.SphereCast(
            transform.position,
            capsule.radius * 0.95f,
            Vector3.up,
            out _,
            castDist,
            groundMask
        );
    }

    // -------------------- Wall Slide --------------------

    void HandleWallSlidePhysics()
    {
        if (!isWallSliding) return;

        if (rb.linearVelocity.y < 0)
        {
            rb.linearVelocity = new Vector3(
                rb.linearVelocity.x,
                Mathf.Max(rb.linearVelocity.y, -wallSlideSpeed),
                rb.linearVelocity.z
            );
        }

        if (enableWallSlideTilt && playerModel)
        {
            Vector3 axis = Vector3.Cross(-wallNormal, Vector3.up);
            playerModel.rotation = Quaternion.Slerp(
                playerModel.rotation,
                Quaternion.AngleAxis(wallSlideTiltAngle, axis) * transform.rotation,
                Time.deltaTime * 8f
            );
        }
    }

    void OnCollisionStay(Collision c)
    {
        if (isGrounded) return;
        if (((1 << c.gameObject.layer) & groundMask) == 0) return;

        foreach (var contact in c.contacts)
        {
            float angle = Vector3.Angle(contact.normal, Vector3.up);
            if (angle > 70f && angle < 110f)
            {
                isWallSliding = true;
                wallNormal = contact.normal;
                return;
            }
        }

        isWallSliding = false;
    }

    void OnCollisionExit(Collision c)
    {
        if (((1 << c.gameObject.layer) & groundMask) != 0)
            isWallSliding = false;
    }

    // -------------------- Actions --------------------

    void Jump()
    {
        rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
        rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
    }

    void WallJump()
    {
        Vector3 dir = (wallNormal + Vector3.up).normalized;
        rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
        rb.AddForce(dir * wallJumpForce, ForceMode.Impulse);

        isWallSliding = false;
        wallJumpTimer = wallJumpDuration;
    }

    // -------------------- Helpers --------------------

    void CheckGround()
    {
        float dist = (capsule.height * 0.5f) + groundDistance;
        isGrounded = Physics.Raycast(transform.position, Vector3.down, dist, groundMask);
        if (isGrounded) isWallSliding = false;
    }

    void ApplyExtraGravity()
    {
        if (!isGrounded && rb.linearVelocity.y < 0 && !isWallSliding)
        {
            rb.AddForce(
                Vector3.down * (gravityMultiplier - 1f) * Physics.gravity.magnitude,
                ForceMode.Acceleration
            );
        }
    }

    void ApplyDrag()
    {
        if (isSliding)
            rb.linearDamping = slideDrag;
        else
            rb.linearDamping = isGrounded ? groundDrag : airDrag;
    }

    void ClampSpeed()
    {
        if (isSliding) return;

        Vector3 horiz = HorizontalVelocity();
        if (horiz.magnitude > maxSpeed)
        {
            Vector3 clamped = horiz.normalized * maxSpeed;
            rb.linearVelocity = new Vector3(clamped.x, rb.linearVelocity.y, clamped.z);
        }
    }

    Vector3 HorizontalVelocity()
    {
        return new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
    }

    void ResetModelRotation(float speed = 10f)
    {
        if (!playerModel) return;

        playerModel.rotation = Quaternion.Slerp(
            playerModel.rotation,
            transform.rotation,
            Time.deltaTime * speed
        );
    }

    void CreateFrictionlessMaterial()
    {
        PhysicsMaterial mat = new PhysicsMaterial("PlayerFrictionless")
        {
            dynamicFriction = 0f,
            staticFriction = 0f,
            bounciness = 0f,
            frictionCombine = PhysicsMaterialCombine.Minimum
        };

        capsule.material = mat;
    }
}
