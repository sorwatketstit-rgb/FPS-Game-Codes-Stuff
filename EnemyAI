using UnityEngine;

public class EnemyAI : MonoBehaviour
{
    [Header("Target")]
    [Tooltip("The player to track (auto-finds if empty)")]
    public Transform player;

    [Header("Detection")]
    [Tooltip("How far enemy can see the player")]
    [Range(5f, 100f)]
    public float detectionRange = 30f;

    [Tooltip("Range at which enemy walks toward player (should be > detection range)")]
    [Range(5f, 150f)]
    public float walkRange = 50f;

    [Tooltip("Show detection ranges in editor")]
    public bool showDetectionRange = true;

    [Header("Movement")]
    [Tooltip("How fast enemy walks toward player")]
    [Range(1f, 20f)]
    public float walkSpeed = 5f;

    [Tooltip("Stop moving when this close to player")]
    [Range(1f, 30f)]
    public float stopDistance = 20f;

    [Tooltip("Use NavMesh for pathfinding")]
    public bool useNavMesh = true;

    [Header("Rotation")]
    [Tooltip("How fast enemy rotates to face player")]
    [Range(1f, 10f)]
    public float rotationSpeed = 3f;

    [Tooltip("Allow enemy to look up/down at player")]
    public bool allowVerticalAiming = true;

    [Tooltip("If vertical aiming disabled, only rotate body on Y axis")]
    public bool lockXZRotation = false;

    [Header("Shooting")]
    [Tooltip("Projectile prefab to spawn")]
    public GameObject projectilePrefab;

    [Tooltip("Where projectile spawns from")]
    public Transform firePoint;

    [Tooltip("Time between shots")]
    [Range(0.1f, 10f)]
    public float fireRate = 2f;

    [Tooltip("Random variation in fire rate")]
    [Range(0f, 2f)]
    public float fireRateVariation = 0.5f;

    [Header("Debug")]
    public bool showDebugInfo = true;

    // Private variables
    private float nextFireTime = 0f;
    private bool canSeePlayer = false;
    private bool shouldWalk = false;
    private Rigidbody rb;
    private UnityEngine.AI.NavMeshAgent navAgent;

    void Start()
    {
        // Get components
        rb = GetComponent<Rigidbody>();
        navAgent = GetComponent<UnityEngine.AI.NavMeshAgent>();

        // Setup NavMesh if enabled
        if (useNavMesh)
        {
            if (navAgent == null)
            {
                Debug.LogError($"{gameObject.name}: Use NavMesh is enabled but no NavMeshAgent component found!");
            }
            else
            {
                navAgent.speed = walkSpeed;
                navAgent.stoppingDistance = stopDistance;
            }
        }
        else if (rb != null)
        {
            rb.freezeRotation = true; // Prevent physics from rotating enemy
        }

        // Auto-find player if not assigned
        if (player == null)
        {
            GameObject playerObj = GameObject.FindGameObjectWithTag("Player");
            if (playerObj != null)
            {
                player = playerObj.transform;
                Debug.Log($"{gameObject.name}: Found player automatically");
            }
            else
            {
                Debug.LogError($"{gameObject.name}: No player found! Tag your player as 'Player'");
                enabled = false;
                return;
            }
        }

        // Validate fire point
        if (firePoint == null)
        {
            Debug.LogWarning($"{gameObject.name}: No fire point assigned, creating one at enemy position");
            GameObject fp = new GameObject("FirePoint");
            fp.transform.SetParent(transform);
            fp.transform.localPosition = Vector3.forward * 0.5f; // Slightly in front
            firePoint = fp.transform;
        }

        // Validate projectile
        if (projectilePrefab == null)
        {
            Debug.LogError($"{gameObject.name}: No projectile prefab assigned!");
        }

        // Validate walk range
        if (walkRange < detectionRange)
        {
            Debug.LogWarning($"{gameObject.name}: Walk range should be larger than detection range!");
            walkRange = detectionRange + 10f;
        }

        // Set initial fire time with variation
        nextFireTime = Time.time + fireRate + Random.Range(-fireRateVariation, fireRateVariation);
    }

    void Update()
    {
        if (player == null) return;

        // Check distances
        float distanceToPlayer = Vector3.Distance(transform.position, player.position);
        canSeePlayer = distanceToPlayer <= detectionRange;
        shouldWalk = distanceToPlayer <= walkRange && distanceToPlayer > stopDistance;

        // Handle NavMesh movement
        if (useNavMesh && navAgent != null)
        {
            if (shouldWalk)
            {
                navAgent.isStopped = false;
                navAgent.SetDestination(player.position);
            }
            else
            {
                navAgent.isStopped = true;
            }
        }

        if (canSeePlayer || shouldWalk)
        {
            // Always rotate toward player when tracking
            RotateTowardPlayer();

            // Only shoot when in shooting range
            if (canSeePlayer && Time.time >= nextFireTime)
            {
                Shoot();

                // Schedule next shot with random variation
                float variance = Random.Range(-fireRateVariation, fireRateVariation);
                nextFireTime = Time.time + fireRate + variance;
            }
        }
    }

    void FixedUpdate()
    {
        // Handle movement in FixedUpdate for physics
        if (shouldWalk && rb != null)
        {
            MoveTowardPlayer();
        }
    }

    void RotateTowardPlayer()
    {
        // Calculate direction to player
        Vector3 direction = player.position - transform.position;

        if (!allowVerticalAiming || lockXZRotation)
        {
            // Only rotate on Y axis (keep enemy upright, no looking up/down)
            direction.y = 0f;
        }

        if (direction.sqrMagnitude > 0.001f)
        {
            // Smoothly rotate toward player
            Quaternion targetRotation = Quaternion.LookRotation(direction);
            transform.rotation = Quaternion.Slerp(
                transform.rotation,
                targetRotation,
                Time.deltaTime * rotationSpeed
            );
        }
    }

    void MoveTowardPlayer()
    {
        // Calculate direction to player (horizontal only for walking)
        Vector3 direction = player.position - transform.position;
        direction.y = 0f; // Keep movement horizontal
        direction.Normalize();

        // Move using Rigidbody
        Vector3 targetVelocity = direction * walkSpeed;

        // Keep vertical velocity (gravity)
        targetVelocity.y = rb.linearVelocity.y;

        // Apply movement
        rb.linearVelocity = Vector3.Lerp(rb.linearVelocity, targetVelocity, Time.fixedDeltaTime * 5f);
    }

    void Shoot()
    {
        if (projectilePrefab == null)
        {
            Debug.LogWarning($"{gameObject.name}: Can't shoot - no projectile prefab!");
            return;
        }

        // Spawn projectile at fire point with FIRE POINT'S rotation (not enemy rotation)
        GameObject projectile = Instantiate(
            projectilePrefab,
            firePoint.position,
            firePoint.rotation  // Use fire point rotation for accurate aim
        );

        if (showDebugInfo)
        {
            Debug.Log($"{gameObject.name}: SHOOT! Direction: {firePoint.forward}");
        }

        // Get projectile script and set velocity properly
        EnemyProjectile projScript = projectile.GetComponent<EnemyProjectile>();
        Rigidbody projRb = projectile.GetComponent<Rigidbody>();

        if (projRb != null && projScript != null)
        {
            // IMPORTANT: Set velocity based on fire point's forward direction
            projRb.linearVelocity = firePoint.forward * projScript.speed;
        }
    }

    // Visualize detection range in editor
    void OnDrawGizmosSelected()
    {
        if (showDetectionRange)
        {
            // Shooting range (red/yellow)
            Gizmos.color = canSeePlayer ? Color.red : Color.yellow;
            Gizmos.DrawWireSphere(transform.position, detectionRange);

            // Walk range (blue)
            Gizmos.color = new Color(0.5f, 0.5f, 1f, 0.3f);
            Gizmos.DrawWireSphere(transform.position, walkRange);

            // Stop distance (green)
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(transform.position, stopDistance);
        }
    }

    // Public methods
    public bool CanSeePlayer() => canSeePlayer;
    public float GetDistanceToPlayer() => player != null ? Vector3.Distance(transform.position, player.position) : float.MaxValue;
}
