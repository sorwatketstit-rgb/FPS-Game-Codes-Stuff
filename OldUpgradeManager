using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

public class UpgradeManager : MonoBehaviour
{
    [Header("Player References")]
    [Tooltip("The player GameObject")]
    public GameObject player;

    [Tooltip("Camera control script - drag ModernFPSCamera here")]
    public ModernFPSCamera cameraControlScript;

    [Tooltip("Pause manager (to disable pausing in upgrade room)")]
    public PauseManager pauseManager;

    [Tooltip("Floor/Level manager - handles progression to next floor (optional if using trigger-based)")]
    public MonoBehaviour floorManager;

    [Header("UI References")]
    [Tooltip("The 3 upgrade choice buttons")]
    public Button upgradeButton1;
    public Button upgradeButton2;
    public Button upgradeButton3;

    [Tooltip("Continue button - shows after upgrade selection (set onClick to next floor in Inspector)")]
    public GameObject continueButton;

    [Tooltip("Text labels for upgrade names (TextMeshPro) - Optional but recommended")]
    public TMPro.TextMeshProUGUI upgradeText1;
    public TMPro.TextMeshProUGUI upgradeText2;
    public TMPro.TextMeshProUGUI upgradeText3;

    [Tooltip("Background blocker panel (prevents clicks going through to game world)")]
    public GameObject uiBlockerPanel;

    [Header("Upgrade Button Images")]
    [Tooltip("Sprite images for each upgrade type (assign in Inspector)")]
    public Sprite moveSpeedSprite;
    public Sprite maxSpeedSprite;
    public Sprite accelerationSprite;
    public Sprite slideBoostSprite;
    public Sprite groundDragSprite;
    public Sprite airDragSprite;
    public Sprite jumpForceSprite;
    public Sprite fireRateSprite;
    public Sprite fullHealSprite;
    public Sprite maxHealthSprite;
    public Sprite scoreMultiplierSprite;
    public Sprite angelicBlunderbussSprite;

    [Header("Upgrade Values - SETS to fixed values (not additive)")]
    [Tooltip("Move speed tiers - each upgrade picks next tier")]
    public float[] moveSpeedTiers = { 35f, 40f, 45f, 50f, 55f };

    [Tooltip("Max speed tiers")]
    public float[] maxSpeedTiers = { 25f, 30f, 35f, 40f, 45f };

    [Tooltip("Acceleration tiers")]
    public float[] accelerationTiers = { 15f, 20f, 25f, 30f, 35f };

    [Tooltip("Slide boost tiers")]
    public float[] slideBoostTiers = { 10f, 15f, 20f, 25f, 30f };

    [Tooltip("Ground drag tiers (lower = less drag, faster movement)")]
    public float[] groundDragTiers = { 4f, 3f, 2f, 1f, 0.5f };

    [Tooltip("Air drag tiers (lower = less drag, better air control)")]
    public float[] airDragTiers = { 1.5f, 1f, 0.5f, 0.2f, 0.1f };

    [Tooltip("Jump force tiers")]
    public float[] jumpForceTiers = { 8f, 10f, 12f, 14f, 16f };

    [Tooltip("Fire rate tiers (LOWER = FASTER: 0.05=fast, 0.01=very fast, 0.001=ultra fast)")]
    public float[] fireRateTiers = { 0.05f, 0.01f, 0.001f };

    [Tooltip("Max health tiers (increases max limb hits)")]
    public int[] maxHealthTiers = { 4, 5, 6 }; // Increases from base 3 hits per limb

    [Tooltip("Score multiplier tiers (points per kill)")]
    public int[] scoreMultiplierTiers = { 10, 15, 20 }; // Base is 5, these are additional

    [Header("Special Upgrades")]
    [Tooltip("Angelic Blunderbuss damage (single tier - unique upgrade)")]
    public int angelicBlunderbussDamage = 3;

    [Tooltip("Angelic Blunderbuss range")]
    public float angelicBlunderbussRange = 50f;

    [Tooltip("Angelic Blunderbuss fire rate")]
    public float angelicBlunderbussFireRate = 0.75f;

    [Tooltip("Normal gun model (will be disabled when Angelic Blunderbuss is acquired)")]
    public GameObject normalGunModel;

    [Tooltip("Angelic Blunderbuss gun model (will be enabled when acquired)")]
    public GameObject angelicBlunderbussModel;

    [Header("Particle Effect (Optional)")]
    [Tooltip("Particle effect to play when upgrade is selected")]
    public GameObject upgradeParticleEffect;

    [Header("Debug")]
    public bool showDebugInfo = true;
    [Tooltip("Show detailed sprite/button assignment logs (creates spam)")]
    public bool showDetailedLogs = false;

    // Private variables
    private List<UpgradeType> availableUpgrades = new List<UpgradeType>();
    private UpgradeType selectedUpgrade1;
    private UpgradeType selectedUpgrade2;
    private UpgradeType selectedUpgrade3;

    // Track how many times each upgrade has been picked
    private int moveSpeedLevel = 0;
    private int maxSpeedLevel = 0;
    private int accelerationLevel = 0;
    private int slideBoostLevel = 0;
    private int groundDragLevel = 0;
    private int airDragLevel = 0;
    private int jumpForceLevel = 0;
    private int fireRateLevel = 0;
    private int maxHealthLevel = 0;
    private int scoreMultiplierLevel = 0;
    private bool hasAngelicBlunderbuss = false; // One-time upgrade
    private bool hasSelectedUpgrade = false;
    private bool isPrewarming = false; // Track if we're prewarming

    // Components to disable
    private MomentumMovement movementScript;
    private PlayerShooting shootingScript;
    private PlayerHealth playerHealth;
    private ScoreManager scoreManager;

    // Enum for upgrade types
    public enum UpgradeType
    {
        MoveSpeed,
        MaxSpeed,
        Acceleration,
        SlideBoost,
        GroundDrag,
        AirDrag,
        JumpForce,
        FireRate,
        FullHeal,
        MaxHealth,
        ScoreMultiplier,
        AngelicBlunderbuss
    }

    void Awake()
    {
        // Initialize upgrade pool EARLY (before Start, before OnEnable)
        InitializeUpgradePool();
    }

    void Start()
    {
        // Validate references
        if (player == null)
        {
            Debug.LogError("UpgradeManager: Player not assigned!");
            enabled = false;
            return;
        }

        // Get player components
        movementScript = player.GetComponent<MomentumMovement>();
        shootingScript = player.GetComponent<PlayerShooting>();
        playerHealth = player.GetComponent<PlayerHealth>();

        if (movementScript == null || shootingScript == null)
        {
            Debug.LogError("UpgradeManager: Missing movement or shooting script on player!");
            enabled = false;
            return;
        }

        if (playerHealth == null)
        {
            Debug.LogWarning("UpgradeManager: PlayerHealth not found! Healing upgrades won't work.");
        }

        // Find ScoreManager in scene
        scoreManager = FindObjectOfType<ScoreManager>();
        if (scoreManager == null)
        {
            Debug.LogWarning("UpgradeManager: ScoreManager not found! Score multiplier upgrades won't work.");
        }

        // Set up button listeners (clear first to prevent duplicates)
        SetupButtonListeners();

        // Hide continue button initially
        if (continueButton != null)
        {
            continueButton.SetActive(false);
        }

        // PREWARM: Activate and deactivate the upgrade room to force initialization
        // Use coroutine with delay to avoid allocation warnings
        StartCoroutine(PrewarmAfterDelay());

        if (showDebugInfo)
        {
            Debug.Log("UpgradeManager initialized!");
        }
    }

    IEnumerator PrewarmAfterDelay()
    {
        // Wait a frame to let Unity finish initialization
        yield return new WaitForEndOfFrame();

        PrewarmUpgradeRoom();

        if (showDebugInfo)
        {
            Debug.Log("Prewarm completed!");
        }
    }

    /// <summary>
    /// Prewarm the upgrade room by activating it once, then immediately deactivating
    /// This ensures everything is initialized before the player actually sees it
    /// </summary>
    void PrewarmUpgradeRoom()
    {
        if (showDebugInfo)
        {
            Debug.Log("Prewarming upgrade room...");
        }

        // Check if the upgrade room GameObject exists
        GameObject upgradeRoomObject = gameObject;

        // Store original active state
        bool wasActive = upgradeRoomObject.activeSelf;

        // Set prewarm flag BEFORE activating
        isPrewarming = true;

        // Activate if not already active (this triggers OnEnable, but it will skip full prep)
        if (!wasActive)
        {
            upgradeRoomObject.SetActive(true);
        }
        else
        {
            // If already active, manually call randomize
            RandomizeUpgrades();
        }

        // Clear prewarm flag
        isPrewarming = false;

        // Deactivate if it wasn't originally active
        if (!wasActive)
        {
            upgradeRoomObject.SetActive(false);
        }

        if (showDebugInfo)
        {
            Debug.Log("Upgrade room prewarmed successfully!");
        }
    }

    void OnEnable()
    {
        // Make sure pool is initialized (safety check)
        if (availableUpgrades.Count == 0)
        {
            InitializeUpgradePool();
        }

        // Re-add button listeners (they might have been removed)
        SetupButtonListeners();

        // If this is prewarm, only randomize upgrades (skip disabling controls, cursor unlock, etc.)
        if (isPrewarming)
        {
            RandomizeUpgrades();
            return;
        }

        // Called when upgrade room is activated (for real)
        PrepareUpgradeRoom();
    }

    void SetupButtonListeners()
    {
        if (upgradeButton1 != null)
        {
            upgradeButton1.onClick.RemoveAllListeners();
            upgradeButton1.onClick.AddListener(() => SelectUpgrade(1));
        }

        if (upgradeButton2 != null)
        {
            upgradeButton2.onClick.RemoveAllListeners();
            upgradeButton2.onClick.AddListener(() => SelectUpgrade(2));
        }

        if (upgradeButton3 != null)
        {
            upgradeButton3.onClick.RemoveAllListeners();
            upgradeButton3.onClick.AddListener(() => SelectUpgrade(3));
        }

        if (showDetailedLogs)
        {
            Debug.Log("Button listeners set up!");
        }
    }

    void OnDisable()
    {
        // Called when leaving upgrade room
        ReenablePlayerControls();

        // Clear button listeners to prevent memory leaks
        if (upgradeButton1 != null)
        {
            upgradeButton1.onClick.RemoveAllListeners();
        }
        if (upgradeButton2 != null)
        {
            upgradeButton2.onClick.RemoveAllListeners();
        }
        if (upgradeButton3 != null)
        {
            upgradeButton3.onClick.RemoveAllListeners();
        }
    }

    void InitializeUpgradePool()
    {
        // Add all upgrade types to the pool
        availableUpgrades.Clear();

        // Common upgrades (add multiple copies for higher chance)
        // Each upgrade added = 1/total pool size probability
        for (int i = 0; i < 10; i++) // 10 copies each = common
        {
            availableUpgrades.Add(UpgradeType.MoveSpeed);
            availableUpgrades.Add(UpgradeType.MaxSpeed);
            availableUpgrades.Add(UpgradeType.Acceleration);
            availableUpgrades.Add(UpgradeType.SlideBoost);
            availableUpgrades.Add(UpgradeType.GroundDrag);
            availableUpgrades.Add(UpgradeType.AirDrag);
            availableUpgrades.Add(UpgradeType.JumpForce);
            availableUpgrades.Add(UpgradeType.FireRate);
        }

        // Healing upgrades (5 copies = less common)
        for (int i = 0; i < 5; i++)
        {
            availableUpgrades.Add(UpgradeType.FullHeal);
            availableUpgrades.Add(UpgradeType.MaxHealth);
        }

        // Score multiplier (5 copies = less common)
        for (int i = 0; i < 5; i++)
        {
            availableUpgrades.Add(UpgradeType.ScoreMultiplier);
        }

        if (!hasAngelicBlunderbuss)
        {
            availableUpgrades.Add(UpgradeType.AngelicBlunderbuss);
        }

        if (showDebugInfo)
        {
            int angelicCount = hasAngelicBlunderbuss ? 0 : 1;
            float angelicChance = angelicCount > 0 ? (angelicCount / (float)availableUpgrades.Count) * 100f : 0f;
            Debug.Log($"Upgrade pool: {availableUpgrades.Count} entries | Angelic Blunderbuss: {angelicChance:F2}% per slot");
        }
    }

    void PrepareUpgradeRoom()
    {
        if (showDebugInfo)
        {
            Debug.Log("=== UPGRADE ROOM ENTERED ===");
        }

        // CRITICAL: Reset selection state
        hasSelectedUpgrade = false;

        // Disable pausing
        if (pauseManager != null)
        {
            pauseManager.SetCanPause(false);

            if (showDebugInfo)
            {
                Debug.Log("Pausing DISABLED in upgrade room");
            }
        }
        else
        {
            Debug.LogWarning("PauseManager reference not set! Cannot disable pausing in upgrade room. Assign it in UpgradeManager Inspector.");
        }

        // Pause game time (freezes timer and animations)
        Time.timeScale = 0f;

        if (showDebugInfo)
        {
            Debug.Log("Game time PAUSED (Time.timeScale = 0)");
        }

        // Disable player controls
        if (movementScript != null)
        {
            movementScript.enabled = false;
        }

        if (shootingScript != null)
        {
            shootingScript.enabled = false;
        }

        // Disable camera movement AND unlock cursor
        if (cameraControlScript != null)
        {
            cameraControlScript.enabled = false;

            if (showDebugInfo)
            {
                Debug.Log($"Disabled camera control: {cameraControlScript.GetType().Name}");
            }
        }

        // Unlock and show cursor for UI interaction
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;

        if (showDebugInfo)
        {
            Debug.Log($"hasSelectedUpgrade reset to FALSE - buttons should work now!");
        }

        // Show upgrade buttons
        if (upgradeButton1 != null) upgradeButton1.gameObject.SetActive(true);
        if (upgradeButton2 != null) upgradeButton2.gameObject.SetActive(true);
        if (upgradeButton3 != null) upgradeButton3.gameObject.SetActive(true);

        // Show Texts
        if (upgradeText1 != null) upgradeText1.gameObject.SetActive(true);
        if (upgradeText2 != null) upgradeText2.gameObject.SetActive(true);
        if (upgradeText3 != null) upgradeText3.gameObject.SetActive(true);

        // Show UI blocker to prevent clicks going through
        if (uiBlockerPanel != null) uiBlockerPanel.SetActive(true);

        if (showDebugInfo)
        {
            Debug.Log("Upgrade buttons set to ACTIVE");
        }

        // Hide continue button
        if (continueButton != null)
        {
            continueButton.SetActive(false);
        }

        // Randomize upgrades for the 3 buttons (even during prewarm)
        RandomizeUpgrades();
    }

    void ReenablePlayerControls()
    {
        if (showDebugInfo)
        {
            Debug.Log("Re-enabling player controls...");
        }

        // Re-enable pausing
        if (pauseManager != null)
        {
            pauseManager.SetCanPause(true);
        }

        // Resume game time
        Time.timeScale = 1f;

        if (showDebugInfo)
        {
            Debug.Log("Game time RESUMED (Time.timeScale = 1)");
        }

        // Re-enable player controls
        if (movementScript != null)
        {
            movementScript.enabled = true;
        }

        if (shootingScript != null)
        {
            shootingScript.enabled = true;
        }

        // Re-enable camera
        if (cameraControlScript != null)
        {
            cameraControlScript.enabled = true;

            if (showDebugInfo)
            {
                Debug.Log($"Re-enabled camera control: {cameraControlScript.GetType().Name}");
            }
        }

        // Lock cursor back for gameplay
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    void RandomizeUpgrades()
    {
        // Build list of upgrades that are NOT at max level
        List<UpgradeType> availableNonMaxUpgrades = new List<UpgradeType>();

        foreach (var upgrade in availableUpgrades)
        {
            bool isMaxed = false;

            switch (upgrade)
            {
                case UpgradeType.MoveSpeed:
                    isMaxed = moveSpeedLevel >= moveSpeedTiers.Length;
                    break;
                case UpgradeType.MaxSpeed:
                    isMaxed = maxSpeedLevel >= maxSpeedTiers.Length;
                    break;
                case UpgradeType.Acceleration:
                    isMaxed = accelerationLevel >= accelerationTiers.Length;
                    break;
                case UpgradeType.SlideBoost:
                    isMaxed = slideBoostLevel >= slideBoostTiers.Length;
                    break;
                case UpgradeType.GroundDrag:
                    isMaxed = groundDragLevel >= groundDragTiers.Length;
                    break;
                case UpgradeType.AirDrag:
                    isMaxed = airDragLevel >= airDragTiers.Length;
                    break;
                case UpgradeType.JumpForce:
                    isMaxed = jumpForceLevel >= jumpForceTiers.Length;
                    break;
                case UpgradeType.FireRate:
                    isMaxed = fireRateLevel >= fireRateTiers.Length;
                    break;
                case UpgradeType.FullHeal:
                    isMaxed = false; // Can always heal
                    break;
                case UpgradeType.MaxHealth:
                    isMaxed = maxHealthLevel >= maxHealthTiers.Length;
                    break;
                case UpgradeType.ScoreMultiplier:
                    isMaxed = scoreMultiplierLevel >= scoreMultiplierTiers.Length;
                    break;
                case UpgradeType.AngelicBlunderbuss:
                    isMaxed = hasAngelicBlunderbuss; // One-time upgrade
                    break;
            }

            if (!isMaxed)
            {
                availableNonMaxUpgrades.Add(upgrade);
            }
        }

        // If less than 3 upgrades available, pad with maxed upgrades
        if (availableNonMaxUpgrades.Count < 3)
        {
            if (showDebugInfo)
            {
                Debug.Log($"Only {availableNonMaxUpgrades.Count} upgrades available - padding with maxed upgrades");
            }

            // Pad with maxed upgrades to fill 3 slots
            foreach (var upgrade in availableUpgrades)
            {
                if (availableNonMaxUpgrades.Count >= 3) break;
                if (!availableNonMaxUpgrades.Contains(upgrade))
                {
                    availableNonMaxUpgrades.Add(upgrade);
                }
            }
        }

        // Make sure we have at least 3 upgrades total
        if (availableNonMaxUpgrades.Count < 3)
        {
            Debug.LogError("UpgradeManager: Not enough upgrade types! Need at least 3.");
            return;
        }

        // Shuffle and pick 3 unique upgrades
        List<UpgradeType> shuffled = new List<UpgradeType>(availableNonMaxUpgrades);

        // Fisher-Yates shuffle
        for (int i = shuffled.Count - 1; i > 0; i--)
        {
            int randomIndex = Random.Range(0, i + 1);
            UpgradeType temp = shuffled[i];
            shuffled[i] = shuffled[randomIndex];
            shuffled[randomIndex] = temp;
        }

        // Assign first 3 shuffled upgrades to buttons
        selectedUpgrade1 = shuffled[0];
        selectedUpgrade2 = shuffled[1];
        selectedUpgrade3 = shuffled[2];

        // Update button sprites
        UpdateButtonSprite(upgradeButton1, selectedUpgrade1);
        UpdateButtonSprite(upgradeButton2, selectedUpgrade2);
        UpdateButtonSprite(upgradeButton3, selectedUpgrade3);

        // Update text labels
        UpdateButtonText(upgradeText1, selectedUpgrade1);
        UpdateButtonText(upgradeText2, selectedUpgrade2);
        UpdateButtonText(upgradeText3, selectedUpgrade3);

        // Warn once if all sprites are the same
        if (showDebugInfo && moveSpeedSprite != null && moveSpeedSprite == maxSpeedSprite && maxSpeedSprite == accelerationSprite)
        {
            Debug.LogWarning("WARNING: All upgrade sprites appear to be the same! Assign unique sprites for each upgrade type in UpgradeManager Inspector.");
        }

        if (showDebugInfo)
        {
            Debug.Log($"Upgrades randomized: {selectedUpgrade1}, {selectedUpgrade2}, {selectedUpgrade3}");
        }
    }

    void UpdateButtonSprite(Button button, UpgradeType upgradeType)
    {
        if (button == null)
        {
            if (showDebugInfo) Debug.LogWarning("UpdateButtonSprite: Button is null!");
            return;
        }

        Image buttonImage = button.GetComponent<Image>();
        if (buttonImage == null)
        {
            if (showDebugInfo) Debug.LogWarning($"UpdateButtonSprite: No Image component on button {button.name}!");
            return;
        }

        // Assign sprite based on upgrade type
        Sprite spriteToAssign = null;

        switch (upgradeType)
        {
            case UpgradeType.MoveSpeed:
                spriteToAssign = moveSpeedSprite;
                break;
            case UpgradeType.MaxSpeed:
                spriteToAssign = maxSpeedSprite;
                break;
            case UpgradeType.Acceleration:
                spriteToAssign = accelerationSprite;
                break;
            case UpgradeType.SlideBoost:
                spriteToAssign = slideBoostSprite;
                break;
            case UpgradeType.GroundDrag:
                spriteToAssign = groundDragSprite;
                break;
            case UpgradeType.AirDrag:
                spriteToAssign = airDragSprite;
                break;
            case UpgradeType.JumpForce:
                spriteToAssign = jumpForceSprite;
                break;
            case UpgradeType.FireRate:
                spriteToAssign = fireRateSprite;
                break;
            case UpgradeType.FullHeal:
                spriteToAssign = fullHealSprite;
                break;
            case UpgradeType.MaxHealth:
                spriteToAssign = maxHealthSprite;
                break;
            case UpgradeType.ScoreMultiplier:
                spriteToAssign = scoreMultiplierSprite;
                break;
            case UpgradeType.AngelicBlunderbuss:
                spriteToAssign = angelicBlunderbussSprite;
                break;
        }

        if (spriteToAssign != null)
        {
            buttonImage.sprite = spriteToAssign;
            if (showDetailedLogs)
            {
                Debug.Log($"Button {button.name}: Assigned {upgradeType} sprite (Sprite name: '{spriteToAssign.name}')");
            }
        }
        else
        {
            if (showDebugInfo) Debug.LogWarning($"No sprite assigned for {upgradeType}! Assign sprites in UpgradeManager Inspector.");
        }
    }

    void SelectUpgrade(int buttonNumber)
    {
        // Prevent multiple selections
        if (hasSelectedUpgrade)
        {
            if (showDebugInfo)
            {
                Debug.LogWarning($"Already selected an upgrade! Ignoring button {buttonNumber}");
            }
            return;
        }

        hasSelectedUpgrade = true;

        if (showDebugInfo)
        {
            Debug.Log($"=== SELECT UPGRADE CALLED: Button {buttonNumber} ===");
        }

        // Determine which upgrade was selected
        UpgradeType selectedUpgrade = UpgradeType.MoveSpeed; // Default

        switch (buttonNumber)
        {
            case 1:
                selectedUpgrade = selectedUpgrade1;
                break;
            case 2:
                selectedUpgrade = selectedUpgrade2;
                break;
            case 3:
                selectedUpgrade = selectedUpgrade3;
                break;
        }

        if (showDebugInfo)
        {
            Debug.Log($"Player selected: {selectedUpgrade} from Button {buttonNumber}");
            Debug.Log($"Button assignments: 1={selectedUpgrade1}, 2={selectedUpgrade2}, 3={selectedUpgrade3}");
        }

        // Apply the upgrade
        ApplyUpgrade(selectedUpgrade);

        // Play particle effect (optional)
        if (upgradeParticleEffect != null && player != null)
        {
            Instantiate(upgradeParticleEffect, player.transform.position, Quaternion.identity);
        }

        // Hide upgrade buttons and show continue button
        if (upgradeButton1 != null) upgradeButton1.gameObject.SetActive(false);
        if (upgradeButton2 != null) upgradeButton2.gameObject.SetActive(false);
        if (upgradeButton3 != null) upgradeButton3.gameObject.SetActive(false);
        if (upgradeText1 != null) upgradeText1.gameObject.SetActive(false);
        if (upgradeText2 != null) upgradeText2.gameObject.SetActive(false);
        if (upgradeText3 != null) upgradeText3.gameObject.SetActive(false);

        // Show continue button (you'll manually add next floor onClick in Inspector)
        if (continueButton != null)
        {
            continueButton.SetActive(true);
        }

        if (showDebugInfo)
        {
            Debug.Log("=== UPGRADE SELECTION COMPLETE - Continue button shown ===");
        }
    }

    /// <summary>
    /// PUBLIC METHOD: Call this from Continue Button's onClick to close upgrade room and unpause
    /// In Inspector: Continue Button -> OnClick() -> UpgradeManager.CloseUpgradeRoom()
    /// </summary>
    public void CloseUpgradeRoom()
    {
        if (showDebugInfo)
        {
            Debug.Log("CloseUpgradeRoom() called - closing upgrade UI and unpausing game");
        }

        // Hide UI blocker
        if (uiBlockerPanel != null) uiBlockerPanel.SetActive(false);

        // Close the upgrade room (this triggers OnDisable which unpauses)
        gameObject.SetActive(false);

        if (showDebugInfo)
        {
            Debug.Log("Upgrade room closed!");
        }
    }

    void UpdateButtonText(TMPro.TextMeshProUGUI textLabel, UpgradeType upgradeType)
    {
        if (textLabel == null) return; // Text labels are optional

        string upgradeName = "";
        string upgradeDesc = "";
        bool isMaxLevel = false;

        switch (upgradeType)
        {
            case UpgradeType.MoveSpeed:
                upgradeName = "Movement Speed";
                if (moveSpeedLevel < moveSpeedTiers.Length)
                    upgradeDesc = $" -> {moveSpeedTiers[moveSpeedLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.MaxSpeed:
                upgradeName = "Max Speed";
                if (maxSpeedLevel < maxSpeedTiers.Length)
                    upgradeDesc = $" -> {maxSpeedTiers[maxSpeedLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.Acceleration:
                upgradeName = "Acceleration";
                if (accelerationLevel < accelerationTiers.Length)
                    upgradeDesc = $" -> {accelerationTiers[accelerationLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.SlideBoost:
                upgradeName = "Slide Boost";
                if (slideBoostLevel < slideBoostTiers.Length)
                    upgradeDesc = $" -> {slideBoostTiers[slideBoostLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.GroundDrag:
                upgradeName = "Ground Friction";
                if (groundDragLevel < groundDragTiers.Length)
                    upgradeDesc = $" -> {groundDragTiers[groundDragLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.AirDrag:
                upgradeName = "Air Control";
                if (airDragLevel < airDragTiers.Length)
                    upgradeDesc = $" -> {airDragTiers[airDragLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.JumpForce:
                upgradeName = "Jump Height";
                if (jumpForceLevel < jumpForceTiers.Length)
                    upgradeDesc = $" -> {jumpForceTiers[jumpForceLevel]}";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.FireRate:
                upgradeName = "Fire Rate";
                if (fireRateLevel < fireRateTiers.Length)
                    upgradeDesc = $" -> {fireRateTiers[fireRateLevel]}s";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.FullHeal:
                upgradeName = "Full Heal";
                upgradeDesc = "Restore All Limbs";
                isMaxLevel = false; // Can always use
                break;
            case UpgradeType.MaxHealth:
                upgradeName = "Max Health";
                if (maxHealthLevel < maxHealthTiers.Length)
                    upgradeDesc = $" > {maxHealthTiers[maxHealthLevel]} hits/limb";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.ScoreMultiplier:
                upgradeName = "Score Multiplier";
                if (scoreMultiplierLevel < scoreMultiplierTiers.Length)
                    upgradeDesc = $" > {scoreMultiplierTiers[scoreMultiplierLevel]} pts/kill";
                else
                {
                    upgradeDesc = "MAX LEVEL";
                    isMaxLevel = true;
                }
                break;
            case UpgradeType.AngelicBlunderbuss:
                upgradeName = "Angelic Blunderbuss";
                if (!hasAngelicBlunderbuss)
                    upgradeDesc = "LEGENDARY WEAPON";
                else
                {
                    upgradeDesc = "ALREADY OWNED";
                    isMaxLevel = true;
                }
                break;
        }

        textLabel.text = $"{upgradeName}\n{upgradeDesc}";

        // Change text color if max level (gold for MAX)
        if (isMaxLevel)
        {
            textLabel.color = new Color(1f, 0.84f, 0f); // Gold color
        }
        else
        {
            textLabel.color = Color.white; // Normal white
        }
    }

    void ApplyUpgrade(UpgradeType upgradeType)
    {
        if (movementScript == null || shootingScript == null) return;

        switch (upgradeType)
        {
            case UpgradeType.MoveSpeed:
                if (moveSpeedLevel < moveSpeedTiers.Length)
                {
                    movementScript.moveSpeed = moveSpeedTiers[moveSpeedLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Move Speed SET to {moveSpeedTiers[moveSpeedLevel]} (Level {moveSpeedLevel + 1})");
                    moveSpeedLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Move Speed already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.MaxSpeed:
                if (maxSpeedLevel < maxSpeedTiers.Length)
                {
                    movementScript.maxSpeed = maxSpeedTiers[maxSpeedLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Max Speed SET to {maxSpeedTiers[maxSpeedLevel]} (Level {maxSpeedLevel + 1})");
                    maxSpeedLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Max Speed already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.Acceleration:
                if (accelerationLevel < accelerationTiers.Length)
                {
                    movementScript.acceleration = accelerationTiers[accelerationLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Acceleration SET to {accelerationTiers[accelerationLevel]} (Level {accelerationLevel + 1})");
                    accelerationLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Acceleration already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.SlideBoost:
                if (slideBoostLevel < slideBoostTiers.Length)
                {
                    movementScript.slideBoost = slideBoostTiers[slideBoostLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Slide Boost SET to {slideBoostTiers[slideBoostLevel]} (Level {slideBoostLevel + 1})");
                    slideBoostLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Slide Boost already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.GroundDrag:
                if (groundDragLevel < groundDragTiers.Length)
                {
                    movementScript.groundDrag = groundDragTiers[groundDragLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Ground Drag SET to {groundDragTiers[groundDragLevel]} (Level {groundDragLevel + 1})");
                    groundDragLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Ground Drag already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.AirDrag:
                if (airDragLevel < airDragTiers.Length)
                {
                    movementScript.airDrag = airDragTiers[airDragLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Air Drag SET to {airDragTiers[airDragLevel]} (Level {airDragLevel + 1})");
                    airDragLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Air Drag already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.JumpForce:
                if (jumpForceLevel < jumpForceTiers.Length)
                {
                    movementScript.jumpForce = jumpForceTiers[jumpForceLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Jump Force SET to {jumpForceTiers[jumpForceLevel]} (Level {jumpForceLevel + 1})");
                    jumpForceLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Jump Force already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.FireRate:
                if (fireRateLevel < fireRateTiers.Length)
                {
                    shootingScript.fireRate = fireRateTiers[fireRateLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Fire Rate SET to {fireRateTiers[fireRateLevel]} (Level {fireRateLevel + 1}) - FASTER SHOOTING!");
                    fireRateLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Fire Rate already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.FullHeal:
                if (playerHealth != null)
                {
                    // Heal all limbs completely
                    for (int i = 0; i < 6; i++)
                    {
                        playerHealth.HealLimb(i);
                        playerHealth.HealLimb(i); // Heal twice to ensure full heal
                        playerHealth.HealLimb(i); // Heal three times to be safe
                    }
                    if (showDebugInfo) Debug.Log("Applied: FULL HEAL - All limbs restored!");
                }
                else
                {
                    if (showDebugInfo) Debug.LogWarning("PlayerHealth not found! Cannot apply Full Heal.");
                }
                break;

            case UpgradeType.MaxHealth:
                if (maxHealthLevel < maxHealthTiers.Length && playerHealth != null)
                {
                    playerHealth.maxHitsPerLimb = maxHealthTiers[maxHealthLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Max Health SET to {maxHealthTiers[maxHealthLevel]} hits per limb (Level {maxHealthLevel + 1})");
                    maxHealthLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Max Health already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.ScoreMultiplier:
                if (scoreMultiplierLevel < scoreMultiplierTiers.Length && scoreManager != null)
                {
                    scoreManager.pointsPerKill = scoreMultiplierTiers[scoreMultiplierLevel];
                    if (showDebugInfo) Debug.Log($"Applied: Score Multiplier SET to {scoreMultiplierTiers[scoreMultiplierLevel]} points per kill (Level {scoreMultiplierLevel + 1})");
                    scoreMultiplierLevel++;
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Score Multiplier already at MAX level! No upgrade applied.");
                }
                break;

            case UpgradeType.AngelicBlunderbuss:
                if (!hasAngelicBlunderbuss)
                {
                    // Max out fire rate first
                    fireRateLevel = fireRateTiers.Length;

                    // Set to Angelic Blunderbuss stats
                    shootingScript.fireRate = angelicBlunderbussFireRate;
                    shootingScript.shootRange = angelicBlunderbussRange;
                    shootingScript.damagePerShot = angelicBlunderbussDamage;

                    // Swap gun models
                    if (normalGunModel != null)
                    {
                        normalGunModel.SetActive(false);
                        if (showDebugInfo) Debug.Log("Normal gun model DISABLED");
                    }

                    if (angelicBlunderbussModel != null)
                    {
                        angelicBlunderbussModel.SetActive(true);
                        if (showDebugInfo) Debug.Log("Angelic Blunderbuss model ENABLED");
                    }

                    hasAngelicBlunderbuss = true;

                    if (showDebugInfo)
                    {
                        Debug.Log("========================================");
                        Debug.Log("ANGELIC BLUNDERBUSS ACQUIRED!");
                        Debug.Log($"Fire Rate: {angelicBlunderbussFireRate}s");
                        Debug.Log($"Damage: {angelicBlunderbussDamage}");
                        Debug.Log($"Range: {angelicBlunderbussRange}");
                        Debug.Log("Gun model swapped!");
                        Debug.Log("========================================");
                    }
                }
                else
                {
                    if (showDebugInfo) Debug.Log("Angelic Blunderbuss already owned!");
                }
                break;
        }
    }

    // Call this when player dies or starts a new run
    public void ResetAllUpgrades()
    {
        // Reset all upgrade levels
        moveSpeedLevel = 0;
        maxSpeedLevel = 0;
        accelerationLevel = 0;
        slideBoostLevel = 0;
        groundDragLevel = 0;
        airDragLevel = 0;
        jumpForceLevel = 0;
        fireRateLevel = 0;
        maxHealthLevel = 0;
        scoreMultiplierLevel = 0;
        hasAngelicBlunderbuss = false;

        if (showDebugInfo)
        {
            Debug.Log("All upgrade levels reset to 0!");
        }
    }

    /// <summary>
    /// PUBLIC METHOD: Call this from the Continue button's onClick to close upgrade room
    /// This will unpause the game and re-enable player controls
    /// </summary>
    public void CloseUpgradeRoom()
    {
        if (showDebugInfo)
        {
            Debug.Log("CloseUpgradeRoom called - closing upgrade room!");
        }

        // Hide UI blocker
        if (uiBlockerPanel != null) uiBlockerPanel.SetActive(false);

        // Hide continue button
        if (continueButton != null) continueButton.SetActive(false);

        // Close upgrade room (triggers OnDisable which unpauses)
        gameObject.SetActive(false);
    }
}
